name: Deploy to GitHub Pages

on:
  release:
    types: [published]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to push commits back to main
    steps:
      - uses: actions/checkout@v5
        with:
          ref: main  # Checkout main branch, not the release tag
          fetch-depth: 0  # Fetch all history to access previous versions

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Validate token list
        run: npm run validate

      - name: Update timestamp
        run: |
          # Update timestamp to current UTC time
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")
          jq --arg ts "$TIMESTAMP" '.timestamp = $ts' tokens/token-list.json > tokens/token-list.json.tmp
          mv tokens/token-list.json.tmp tokens/token-list.json
          
          # Commit timestamp update if changed (skip husky hooks in CI)
          if ! git diff --quiet tokens/token-list.json; then
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add tokens/token-list.json
            HUSKY=0 git commit -m "chore: Update timestamp for release [skip ci]"
            git push origin main
          fi

      - name: Preserve current version as historical snapshot
        run: |
          # Get the current version being deployed
          CURRENT_VERSION=$(jq -r '"\(.version.major).\(.version.minor).\(.version.patch)"' tokens/token-list.json)
          
          # Check if this version already exists in versions/
          if [ ! -f "versions/v${CURRENT_VERSION}.json" ]; then
            mkdir -p versions
            cp tokens/token-list.json versions/v${CURRENT_VERSION}.json
            echo "Preserved v${CURRENT_VERSION}.json as historical snapshot"
            
            # Commit the historical snapshot back to main (skip husky hooks in CI)
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add versions/v${CURRENT_VERSION}.json
            HUSKY=0 git commit -m "chore: Preserve v${CURRENT_VERSION}.json as historical snapshot [skip ci]"
            git push origin main
          else
            echo "v${CURRENT_VERSION}.json already exists in versions/ directory"
          fi

      - name: Create dist directory
        run: |
          mkdir -p dist
          
          # Extract version components
          VERSION=$(jq -r '"\(.version.major).\(.version.minor).\(.version.patch)"' tokens/token-list.json)
          MAJOR=$(jq -r '.version.major' tokens/token-list.json)
          MINOR=$(jq -r '.version.minor' tokens/token-list.json)
          
          # Copy current version with full version (e.g., v1.1.0.json)
          cp tokens/token-list.json dist/v${VERSION}.json
          
          # Copy with major.minor version (e.g., v1.1.json) - updates automatically
          cp tokens/token-list.json dist/v${MAJOR}.${MINOR}.json
          
          # Copy with major version only (e.g., v1.json) - updates automatically
          cp tokens/token-list.json dist/v${MAJOR}.json
          
          # Copy as latest (always points to newest)
          cp tokens/token-list.json dist/latest.json
          
          # Copy base file
          cp tokens/token-list.json dist/token-list.json
          
          # Copy all historical versions and create major.minor and major aliases
          if [ -d "versions" ]; then
            # Declare associative arrays to track highest versions
            declare -A highest_patch  # tracks highest patch for each major.minor
            declare -A highest_minor  # tracks highest minor.patch for each major
            
            for version_file in versions/*.json; do
              if [ -f "$version_file" ]; then
                # Copy the full version file (e.g., v1.2.0.json)
                cp "$version_file" dist/
                
                # Extract version components from the file content
                FILE_MAJOR=$(jq -r '.version.major' "$version_file")
                FILE_MINOR=$(jq -r '.version.minor' "$version_file")
                FILE_PATCH=$(jq -r '.version.patch' "$version_file")
                
                # Skip if this is the current version's major (already created above)
                if [ "$FILE_MAJOR" = "$MAJOR" ]; then
                  echo "Skipping major alias v${FILE_MAJOR}.json - current version takes precedence"
                  # But still process minor alias if different minor version
                  if [ "$FILE_MINOR" = "$MINOR" ]; then
                    echo "Skipping minor alias v${FILE_MAJOR}.${FILE_MINOR}.json - current version takes precedence"
                    continue
                  fi
                fi
                
                # Create/update major.minor alias (e.g., v1.2.json)
                MINOR_KEY="${FILE_MAJOR}.${FILE_MINOR}"
                MINOR_ALIAS="v${MINOR_KEY}.json"
                CURRENT_PATCH=${highest_patch[$MINOR_KEY]:-"-1"}
                if [ "$FILE_PATCH" -gt "$CURRENT_PATCH" ]; then
                  cp "$version_file" "dist/${MINOR_ALIAS}"
                  highest_patch[$MINOR_KEY]=$FILE_PATCH
                  echo "Created/updated alias ${MINOR_ALIAS} from $(basename $version_file)"
                fi
                
                # Create/update major alias (e.g., v1.json) - only for non-current majors
                if [ "$FILE_MAJOR" != "$MAJOR" ]; then
                  MAJOR_ALIAS="v${FILE_MAJOR}.json"
                  # Compare as "minor.patch" to find highest version within major
                  CURRENT_MINOR_PATCH=${highest_minor[$FILE_MAJOR]:-"-1.-1"}
                  CURRENT_M=$(echo $CURRENT_MINOR_PATCH | cut -d. -f1)
                  CURRENT_P=$(echo $CURRENT_MINOR_PATCH | cut -d. -f2)
                  if [ "$FILE_MINOR" -gt "$CURRENT_M" ] || ([ "$FILE_MINOR" = "$CURRENT_M" ] && [ "$FILE_PATCH" -gt "$CURRENT_P" ]); then
                    cp "$version_file" "dist/${MAJOR_ALIAS}"
                    highest_minor[$FILE_MAJOR]="${FILE_MINOR}.${FILE_PATCH}"
                    echo "Created/updated alias ${MAJOR_ALIAS} from $(basename $version_file)"
                  fi
                fi
              fi
            done
            echo "Copied historical versions and created aliases"
          fi
          
          # Create index.html that redirects to latest.json
          cat > dist/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="utf-8">
            <title>Request Network Token List</title>
            <meta http-equiv="refresh" content="0; url=latest.json">
          </head>
          <body>
            <p>Redirecting to <a href="latest.json">latest.json</a>...</p>
          </body>
          </html>
          EOF
          
          echo "Created versioned files: v${VERSION}.json, v${MAJOR}.${MINOR}.json, v${MAJOR}.json, latest.json"

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
